#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Mar 30 15:54:06 2011 by generateDS.py version 2.4c.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
STRING_CLEANUP_PAT = re_.compile(r"[\n\r\s]+")

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class TSchema(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Alias=None, Namespace=None, Using=None, Association=None, ComplexType=None, EntityType=None, Function=None, EntityContainer=None):
        self.Alias = _cast(None, Alias)
        self.Namespace = _cast(None, Namespace)
        if Using is None:
            self.Using = []
        else:
            self.Using = Using
        if Association is None:
            self.Association = []
        else:
            self.Association = Association
        if ComplexType is None:
            self.ComplexType = []
        else:
            self.ComplexType = ComplexType
        if EntityType is None:
            self.EntityType = []
        else:
            self.EntityType = EntityType
        if Function is None:
            self.Function = []
        else:
            self.Function = Function
        self.EntityContainer = EntityContainer
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TSchema.subclass:
            return TSchema.subclass(*args_, **kwargs_)
        else:
            return TSchema(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Using(self): return self.Using
    def set_Using(self, Using): self.Using = Using
    def add_Using(self, value): self.Using.append(value)
    def insert_Using(self, index, value): self.Using[index] = value
    def get_Association(self): return self.Association
    def set_Association(self, Association): self.Association = Association
    def add_Association(self, value): self.Association.append(value)
    def insert_Association(self, index, value): self.Association[index] = value
    def get_ComplexType(self): return self.ComplexType
    def set_ComplexType(self, ComplexType): self.ComplexType = ComplexType
    def add_ComplexType(self, value): self.ComplexType.append(value)
    def insert_ComplexType(self, index, value): self.ComplexType[index] = value
    def get_EntityType(self): return self.EntityType
    def set_EntityType(self, EntityType): self.EntityType = EntityType
    def add_EntityType(self, value): self.EntityType.append(value)
    def insert_EntityType(self, index, value): self.EntityType[index] = value
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def add_Function(self, value): self.Function.append(value)
    def insert_Function(self, index, value): self.Function[index] = value
    def get_EntityContainer(self): return self.EntityContainer
    def set_EntityContainer(self, EntityContainer): self.EntityContainer = EntityContainer
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TSchema', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TSchema')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TSchema'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Alias is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            outfile.write(' Alias=%s' % (quote_attrib(self.Alias), ))
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            outfile.write(' Namespace=%s' % (quote_attrib(self.Namespace), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TSchema', fromsubclass_=False):
        for Using_ in self.Using:
            Using_.export(outfile, level, namespace_, name_='Using')
        for Association_ in self.Association:
            Association_.export(outfile, level, namespace_, name_='Association')
        for ComplexType_ in self.ComplexType:
            ComplexType_.export(outfile, level, namespace_, name_='ComplexType')
        for EntityType_ in self.EntityType:
            EntityType_.export(outfile, level, namespace_, name_='EntityType')
        for Function_ in self.Function:
            Function_.export(outfile, level, namespace_, name_='Function')
        if self.EntityContainer:
            self.EntityContainer.export(outfile, level, namespace_, name_='EntityContainer', )
    def hasContent_(self):
        if (
            self.Using or
            self.Association or
            self.ComplexType or
            self.EntityType or
            self.Function or
            self.EntityContainer is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TSchema'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Alias is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            showIndent(outfile, level)
            outfile.write('Alias = %s,\n' % (self.Alias,))
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            showIndent(outfile, level)
            outfile.write('Namespace = %s,\n' % (self.Namespace,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Using=[\n')
        level += 1
        for Using_ in self.Using:
            showIndent(outfile, level)
            outfile.write('model_.TUsing(\n')
            Using_.exportLiteral(outfile, level, name_='TUsing')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Association=[\n')
        level += 1
        for Association_ in self.Association:
            showIndent(outfile, level)
            outfile.write('model_.TAssociation(\n')
            Association_.exportLiteral(outfile, level, name_='TAssociation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ComplexType=[\n')
        level += 1
        for ComplexType_ in self.ComplexType:
            showIndent(outfile, level)
            outfile.write('model_.TComplexType(\n')
            ComplexType_.exportLiteral(outfile, level, name_='TComplexType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EntityType=[\n')
        level += 1
        for EntityType_ in self.EntityType:
            showIndent(outfile, level)
            outfile.write('model_.TEntityType(\n')
            EntityType_.exportLiteral(outfile, level, name_='TEntityType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Function=[\n')
        level += 1
        for Function_ in self.Function:
            showIndent(outfile, level)
            outfile.write('model_.TFunction(\n')
            Function_.exportLiteral(outfile, level, name_='TFunction')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.EntityContainer is not None:
            showIndent(outfile, level)
            outfile.write('EntityContainer=model_.EntityContainer(\n')
            self.EntityContainer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Alias')
        if value is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            self.Alias = value
        value = attrs.get('Namespace')
        if value is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            self.Namespace = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Using': 
            obj_ = TUsing.factory()
            obj_.build(child_)
            self.Using.append(obj_)
        elif nodeName_ == 'Association': 
            obj_ = TAssociation.factory()
            obj_.build(child_)
            self.Association.append(obj_)
        elif nodeName_ == 'ComplexType': 
            obj_ = TComplexType.factory()
            obj_.build(child_)
            self.ComplexType.append(obj_)
        elif nodeName_ == 'EntityType': 
            obj_ = TEntityType.factory()
            obj_.build(child_)
            self.EntityType.append(obj_)
        elif nodeName_ == 'Function': 
            obj_ = TFunction.factory()
            obj_.build(child_)
            self.Function.append(obj_)
        elif nodeName_ == 'EntityContainer': 
            obj_ = EntityContainer.factory()
            obj_.build(child_)
            self.set_EntityContainer(obj_)
# end class TSchema


class TDocumentation(GeneratedsSuper):
    """The Documentation element is used to provide documentation of
    comments on the contents of the XML file. It is valid under
    Schema, Type, Index and Relationship elements."""
    subclass = None
    superclass = None
    def __init__(self, Summary=None, LongDescription=None):
        self.Summary = Summary
        self.LongDescription = LongDescription
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TDocumentation.subclass:
            return TDocumentation.subclass(*args_, **kwargs_)
        else:
            return TDocumentation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Summary(self): return self.Summary
    def set_Summary(self, Summary): self.Summary = Summary
    def get_LongDescription(self): return self.LongDescription
    def set_LongDescription(self, LongDescription): self.LongDescription = LongDescription
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TDocumentation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TDocumentation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TDocumentation'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TDocumentation', fromsubclass_=False):
        if self.Summary:
            self.Summary.export(outfile, level, namespace_, name_='Summary')
        if self.LongDescription:
            self.LongDescription.export(outfile, level, namespace_, name_='LongDescription')
    def hasContent_(self):
        if (
            self.Summary is not None or
            self.LongDescription is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TDocumentation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Summary is not None:
            showIndent(outfile, level)
            outfile.write('Summary=model_.TText(\n')
            self.Summary.exportLiteral(outfile, level, name_='Summary')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LongDescription is not None:
            showIndent(outfile, level)
            outfile.write('LongDescription=model_.TText(\n')
            self.LongDescription.exportLiteral(outfile, level, name_='LongDescription')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Summary': 
            obj_ = TText.factory()
            obj_.build(child_)
            self.set_Summary(obj_)
        elif nodeName_ == 'LongDescription': 
            obj_ = TText.factory()
            obj_.build(child_)
            self.set_LongDescription(obj_)
# end class TDocumentation


class TText(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TText.subclass:
            return TText.subclass(*args_, **kwargs_)
        else:
            return TText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TText', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TText')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TText'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TText', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class TText


class TXmlOrText(GeneratedsSuper):
    """This type allows pretty much any content"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, mixedclass_=None, content_=None):
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TXmlOrText.subclass:
            return TXmlOrText.subclass(*args_, **kwargs_)
        else:
            return TXmlOrText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TXmlOrText', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TXmlOrText')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TXmlOrText'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TXmlOrText', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TXmlOrText'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class TXmlOrText


class TUsing(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Alias=None, Namespace=None, Documentation=None):
        self.Alias = _cast(None, Alias)
        self.Namespace = _cast(None, Namespace)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TUsing.subclass:
            return TUsing.subclass(*args_, **kwargs_)
        else:
            return TUsing(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TUsing', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TUsing')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TUsing'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Alias is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            outfile.write(' Alias=%s' % (quote_attrib(self.Alias), ))
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            outfile.write(' Namespace=%s' % (quote_attrib(self.Namespace), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TUsing', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TUsing'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Alias is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            showIndent(outfile, level)
            outfile.write('Alias = %s,\n' % (self.Alias,))
        if self.Namespace is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            showIndent(outfile, level)
            outfile.write('Namespace = %s,\n' % (self.Namespace,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Alias')
        if value is not None and 'Alias' not in already_processed:
            already_processed.append('Alias')
            self.Alias = value
        value = attrs.get('Namespace')
        if value is not None and 'Namespace' not in already_processed:
            already_processed.append('Namespace')
            self.Namespace = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TUsing


class TAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Documentation=None, End=None, ReferentialConstraint=None):
        self.Name = _cast(None, Name)
        self.Documentation = Documentation
        if End is None:
            self.End = []
        else:
            self.End = End
        self.ReferentialConstraint = ReferentialConstraint
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TAssociation.subclass:
            return TAssociation.subclass(*args_, **kwargs_)
        else:
            return TAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_End(self): return self.End
    def set_End(self, End): self.End = End
    def add_End(self, value): self.End.append(value)
    def insert_End(self, index, value): self.End[index] = value
    def get_ReferentialConstraint(self): return self.ReferentialConstraint
    def set_ReferentialConstraint(self, ReferentialConstraint): self.ReferentialConstraint = ReferentialConstraint
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TAssociation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TAssociation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TAssociation'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TAssociation', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for End_ in self.End:
            End_.export(outfile, level, namespace_, name_='End')
        if self.ReferentialConstraint:
            self.ReferentialConstraint.export(outfile, level, namespace_, name_='ReferentialConstraint')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.End or
            self.ReferentialConstraint is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TAssociation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('End=[\n')
        level += 1
        for End_ in self.End:
            showIndent(outfile, level)
            outfile.write('model_.TAssociationEnd(\n')
            End_.exportLiteral(outfile, level, name_='TAssociationEnd')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ReferentialConstraint is not None:
            showIndent(outfile, level)
            outfile.write('ReferentialConstraint=model_.TConstraint(\n')
            self.ReferentialConstraint.exportLiteral(outfile, level, name_='ReferentialConstraint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'End': 
            obj_ = TAssociationEnd.factory()
            obj_.build(child_)
            self.End.append(obj_)
        elif nodeName_ == 'ReferentialConstraint': 
            obj_ = TConstraint.factory()
            obj_.build(child_)
            self.set_ReferentialConstraint(obj_)
# end class TAssociation


class TComplexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TypeAccess=None, Name=None, Documentation=None, Property=None):
        self.TypeAccess = _cast(None, TypeAccess)
        self.Name = _cast(None, Name)
        self.Documentation = Documentation
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TComplexType.subclass:
            return TComplexType.subclass(*args_, **kwargs_)
        else:
            return TComplexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def get_TypeAccess(self): return self.TypeAccess
    def set_TypeAccess(self, TypeAccess): self.TypeAccess = TypeAccess
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TComplexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TComplexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TComplexType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            outfile.write(' TypeAccess=%s' % (self.gds_format_string(quote_attrib(self.TypeAccess).encode(ExternalEncoding), input_name='TypeAccess'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TComplexType', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.Property
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TComplexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            showIndent(outfile, level)
            outfile.write('TypeAccess = "%s",\n' % (self.TypeAccess,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.TComplexTypeProperty(\n')
            Property_.exportLiteral(outfile, level, name_='TComplexTypeProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('TypeAccess')
        if value is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            self.TypeAccess = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'Property': 
            obj_ = TComplexTypeProperty.factory()
            obj_.build(child_)
            self.Property.append(obj_)
# end class TComplexType


class TConstraint(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Documentation=None, Principal=None, Dependent=None):
        self.Documentation = Documentation
        self.Principal = Principal
        self.Dependent = Dependent
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TConstraint.subclass:
            return TConstraint.subclass(*args_, **kwargs_)
        else:
            return TConstraint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Principal(self): return self.Principal
    def set_Principal(self, Principal): self.Principal = Principal
    def get_Dependent(self): return self.Dependent
    def set_Dependent(self, Dependent): self.Dependent = Dependent
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TConstraint', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TConstraint')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TConstraint'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TConstraint', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        if self.Principal:
            self.Principal.export(outfile, level, namespace_, name_='Principal', )
        if self.Dependent:
            self.Dependent.export(outfile, level, namespace_, name_='Dependent', )
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.Principal is not None or
            self.Dependent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TConstraint'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Principal is not None:
            showIndent(outfile, level)
            outfile.write('Principal=model_.TReferentialConstraintRoleElement(\n')
            self.Principal.exportLiteral(outfile, level, name_='Principal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dependent is not None:
            showIndent(outfile, level)
            outfile.write('Dependent=model_.TReferentialConstraintRoleElement(\n')
            self.Dependent.exportLiteral(outfile, level, name_='Dependent')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'Principal': 
            obj_ = TReferentialConstraintRoleElement.factory()
            obj_.build(child_)
            self.set_Principal(obj_)
        elif nodeName_ == 'Dependent': 
            obj_ = TReferentialConstraintRoleElement.factory()
            obj_.build(child_)
            self.set_Dependent(obj_)
# end class TConstraint


class TReferentialConstraintRoleElement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Role=None, PropertyRef=None):
        self.Role = _cast(None, Role)
        if PropertyRef is None:
            self.PropertyRef = []
        else:
            self.PropertyRef = PropertyRef
    def factory(*args_, **kwargs_):
        if TReferentialConstraintRoleElement.subclass:
            return TReferentialConstraintRoleElement.subclass(*args_, **kwargs_)
        else:
            return TReferentialConstraintRoleElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyRef(self): return self.PropertyRef
    def set_PropertyRef(self, PropertyRef): self.PropertyRef = PropertyRef
    def add_PropertyRef(self, value): self.PropertyRef.append(value)
    def insert_PropertyRef(self, index, value): self.PropertyRef[index] = value
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def export(self, outfile, level, namespace_='edm:', name_='TReferentialConstraintRoleElement', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TReferentialConstraintRoleElement')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TReferentialConstraintRoleElement'):
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            outfile.write(' Role=%s' % (quote_attrib(self.Role), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TReferentialConstraintRoleElement', fromsubclass_=False):
        for PropertyRef_ in self.PropertyRef:
            PropertyRef_.export(outfile, level, namespace_, name_='PropertyRef')
    def hasContent_(self):
        if (
            self.PropertyRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TReferentialConstraintRoleElement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            showIndent(outfile, level)
            outfile.write('Role = %s,\n' % (self.Role,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PropertyRef=[\n')
        level += 1
        for PropertyRef_ in self.PropertyRef:
            showIndent(outfile, level)
            outfile.write('model_.TPropertyRef(\n')
            PropertyRef_.exportLiteral(outfile, level, name_='TPropertyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Role')
        if value is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            self.Role = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyRef': 
            obj_ = TPropertyRef.factory()
            obj_.build(child_)
            self.PropertyRef.append(obj_)
# end class TReferentialConstraintRoleElement


class TNavigationProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Relationship=None, ToRole=None, GetterAccess=None, SetterAccess=None, FromRole=None, Documentation=None):
        self.Name = _cast(None, Name)
        self.Relationship = _cast(None, Relationship)
        self.ToRole = _cast(None, ToRole)
        self.GetterAccess = _cast(None, GetterAccess)
        self.SetterAccess = _cast(None, SetterAccess)
        self.FromRole = _cast(None, FromRole)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TNavigationProperty.subclass:
            return TNavigationProperty.subclass(*args_, **kwargs_)
        else:
            return TNavigationProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Relationship(self): return self.Relationship
    def set_Relationship(self, Relationship): self.Relationship = Relationship
    def get_ToRole(self): return self.ToRole
    def set_ToRole(self, ToRole): self.ToRole = ToRole
    def get_GetterAccess(self): return self.GetterAccess
    def set_GetterAccess(self, GetterAccess): self.GetterAccess = GetterAccess
    def get_SetterAccess(self): return self.SetterAccess
    def set_SetterAccess(self, SetterAccess): self.SetterAccess = SetterAccess
    def get_FromRole(self): return self.FromRole
    def set_FromRole(self, FromRole): self.FromRole = FromRole
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TNavigationProperty', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TNavigationProperty')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TNavigationProperty'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Relationship is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            outfile.write(' Relationship=%s' % (quote_attrib(self.Relationship), ))
        if self.ToRole is not None and 'ToRole' not in already_processed:
            already_processed.append('ToRole')
            outfile.write(' ToRole=%s' % (quote_attrib(self.ToRole), ))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            outfile.write(' GetterAccess=%s' % (self.gds_format_string(quote_attrib(self.GetterAccess).encode(ExternalEncoding), input_name='GetterAccess'), ))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            outfile.write(' SetterAccess=%s' % (self.gds_format_string(quote_attrib(self.SetterAccess).encode(ExternalEncoding), input_name='SetterAccess'), ))
        if self.FromRole is not None and 'FromRole' not in already_processed:
            already_processed.append('FromRole')
            outfile.write(' FromRole=%s' % (quote_attrib(self.FromRole), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TNavigationProperty', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TNavigationProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Relationship is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            showIndent(outfile, level)
            outfile.write('Relationship = %s,\n' % (self.Relationship,))
        if self.ToRole is not None and 'ToRole' not in already_processed:
            already_processed.append('ToRole')
            showIndent(outfile, level)
            outfile.write('ToRole = %s,\n' % (self.ToRole,))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            showIndent(outfile, level)
            outfile.write('GetterAccess = "%s",\n' % (self.GetterAccess,))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            showIndent(outfile, level)
            outfile.write('SetterAccess = "%s",\n' % (self.SetterAccess,))
        if self.FromRole is not None and 'FromRole' not in already_processed:
            already_processed.append('FromRole')
            showIndent(outfile, level)
            outfile.write('FromRole = %s,\n' % (self.FromRole,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Relationship')
        if value is not None and 'Relationship' not in already_processed:
            already_processed.append('Relationship')
            self.Relationship = value
        value = attrs.get('ToRole')
        if value is not None and 'ToRole' not in already_processed:
            already_processed.append('ToRole')
            self.ToRole = value
        value = attrs.get('GetterAccess')
        if value is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            self.GetterAccess = value
        value = attrs.get('SetterAccess')
        if value is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            self.SetterAccess = value
        value = attrs.get('FromRole')
        if value is not None and 'FromRole' not in already_processed:
            already_processed.append('FromRole')
            self.FromRole = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TNavigationProperty


class TEntityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TypeAccess=None, Name=None, Documentation=None, Key=None, Property=None, NavigationProperty=None):
        self.TypeAccess = _cast(None, TypeAccess)
        self.Name = _cast(None, Name)
        self.Documentation = Documentation
        self.Key = Key
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if NavigationProperty is None:
            self.NavigationProperty = []
        else:
            self.NavigationProperty = NavigationProperty
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TEntityType.subclass:
            return TEntityType.subclass(*args_, **kwargs_)
        else:
            return TEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property(self, index, value): self.Property[index] = value
    def get_NavigationProperty(self): return self.NavigationProperty
    def set_NavigationProperty(self, NavigationProperty): self.NavigationProperty = NavigationProperty
    def add_NavigationProperty(self, value): self.NavigationProperty.append(value)
    def insert_NavigationProperty(self, index, value): self.NavigationProperty[index] = value
    def get_TypeAccess(self): return self.TypeAccess
    def set_TypeAccess(self, TypeAccess): self.TypeAccess = TypeAccess
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TEntityType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TEntityType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TEntityType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            outfile.write(' TypeAccess=%s' % (self.gds_format_string(quote_attrib(self.TypeAccess).encode(ExternalEncoding), input_name='TypeAccess'), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TEntityType', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        if self.Key:
            self.Key.export(outfile, level, namespace_, name_='Key')
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property')
        for NavigationProperty_ in self.NavigationProperty:
            NavigationProperty_.export(outfile, level, namespace_, name_='NavigationProperty')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.Key is not None or
            self.Property or
            self.NavigationProperty
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TEntityType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            showIndent(outfile, level)
            outfile.write('TypeAccess = "%s",\n' % (self.TypeAccess,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=model_.TEntityKeyElement(\n')
            self.Key.exportLiteral(outfile, level, name_='Key')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.TEntityProperty(\n')
            Property_.exportLiteral(outfile, level, name_='TEntityProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NavigationProperty=[\n')
        level += 1
        for NavigationProperty_ in self.NavigationProperty:
            showIndent(outfile, level)
            outfile.write('model_.TNavigationProperty(\n')
            NavigationProperty_.exportLiteral(outfile, level, name_='TNavigationProperty')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('TypeAccess')
        if value is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            self.TypeAccess = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'Key': 
            obj_ = TEntityKeyElement.factory()
            obj_.build(child_)
            self.set_Key(obj_)
        elif nodeName_ == 'Property': 
            obj_ = TEntityProperty.factory()
            obj_.build(child_)
            self.Property.append(obj_)
        elif nodeName_ == 'NavigationProperty': 
            obj_ = TNavigationProperty.factory()
            obj_.build(child_)
            self.NavigationProperty.append(obj_)
# end class TEntityType


class TFunction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Name=None, Nullable=None, DefaultValue=None, Precision=None, Collation=None, ReturnType_attr=None, Unicode=None, MaxLength=None, Documentation=None, Parameter=None, DefiningExpression=None, ReturnType=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Collation = _cast(None, Collation)
        self.ReturnType_attr = _cast(None, ReturnType_attr)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Documentation = Documentation
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
        self.DefiningExpression = DefiningExpression
        self.ReturnType = ReturnType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TFunction.subclass:
            return TFunction.subclass(*args_, **kwargs_)
        else:
            return TFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def get_DefiningExpression(self): return self.DefiningExpression
    def set_DefiningExpression(self, DefiningExpression): self.DefiningExpression = DefiningExpression
    def get_ReturnType(self): return self.ReturnType
    def set_ReturnType(self, ReturnType): self.ReturnType = ReturnType
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_ReturnType_attr(self): return self.ReturnType_attr
    def set_ReturnType_attr(self, ReturnType_attr): self.ReturnType_attr = ReturnType_attr
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TFunction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TFunction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TFunction'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.ReturnType_attr is not None and 'ReturnType_attr' not in already_processed:
            already_processed.append('ReturnType_attr')
            outfile.write(' ReturnType_attr=%s' % (self.gds_format_string(quote_attrib(self.ReturnType_attr).encode(ExternalEncoding), input_name='ReturnType_attr'), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TFunction', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
        if self.DefiningExpression is not None:
            showIndent(outfile, level)
            outfile.write('<%sDefiningExpression>%s</%sDefiningExpression>\n' % (namespace_, self.gds_format_string(quote_xml(self.DefiningExpression).encode(ExternalEncoding), input_name='DefiningExpression'), namespace_))
        if self.ReturnType:
            self.ReturnType.export(outfile, level, namespace_, name_='ReturnType')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.Parameter or
            self.DefiningExpression is not None or
            self.ReturnType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TFunction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.ReturnType_attr is not None and 'ReturnType_attr' not in already_processed:
            already_processed.append('ReturnType_attr')
            showIndent(outfile, level)
            outfile.write('ReturnType_attr = "%s",\n' % (self.ReturnType_attr,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.TFunctionParameter(\n')
            Parameter_.exportLiteral(outfile, level, name_='TFunctionParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DefiningExpression is not None:
            showIndent(outfile, level)
            outfile.write('DefiningExpression=%s,\n' % quote_python(self.DefiningExpression).encode(ExternalEncoding))
        if self.ReturnType is not None:
            showIndent(outfile, level)
            outfile.write('ReturnType=model_.TFunctionReturnType(\n')
            self.ReturnType.exportLiteral(outfile, level, name_='ReturnType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('ReturnType_attr')
        if value is not None and 'ReturnType_attr' not in already_processed:
            already_processed.append('ReturnType_attr')
            self.ReturnType_attr = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'Parameter': 
            obj_ = TFunctionParameter.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
        elif nodeName_ == 'DefiningExpression':
            DefiningExpression_ = child_.text
            DefiningExpression_ = self.gds_validate_string(DefiningExpression_, node, 'DefiningExpression')
            self.DefiningExpression = DefiningExpression_
        elif nodeName_ == 'ReturnType': 
            obj_ = TFunctionReturnType.factory()
            obj_.build(child_)
            self.set_ReturnType(obj_)
# end class TFunction


class TFunctionParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Name=None, Nullable=None, DefaultValue=None, Precision=None, Unicode=None, MaxLength=None, Collation=None, Type=None, CollectionType=None, ReferenceType=None, RowType=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.CollectionType = CollectionType
        self.ReferenceType = ReferenceType
        self.RowType = RowType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TFunctionParameter.subclass:
            return TFunctionParameter.subclass(*args_, **kwargs_)
        else:
            return TFunctionParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionType(self): return self.CollectionType
    def set_CollectionType(self, CollectionType): self.CollectionType = CollectionType
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def get_RowType(self): return self.RowType
    def set_RowType(self, RowType): self.RowType = RowType
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TFunctionParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TFunctionParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TFunctionParameter'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TFunctionParameter', fromsubclass_=False):
        if self.CollectionType:
            self.CollectionType.export(outfile, level, namespace_, name_='CollectionType')
        if self.ReferenceType:
            self.ReferenceType.export(outfile, level, namespace_, name_='ReferenceType')
        if self.RowType:
            self.RowType.export(outfile, level, namespace_, name_='RowType')
    def hasContent_(self):
        if (
            self.CollectionType is not None or
            self.ReferenceType is not None or
            self.RowType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TFunctionParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CollectionType is not None:
            showIndent(outfile, level)
            outfile.write('CollectionType=model_.TCollectionType(\n')
            self.CollectionType.exportLiteral(outfile, level, name_='CollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReferenceType is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceType=model_.TReferenceType(\n')
            self.ReferenceType.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RowType is not None:
            showIndent(outfile, level)
            outfile.write('RowType=model_.TRowType(\n')
            self.RowType.exportLiteral(outfile, level, name_='RowType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionType': 
            obj_ = TCollectionType.factory()
            obj_.build(child_)
            self.set_CollectionType(obj_)
        elif nodeName_ == 'ReferenceType': 
            obj_ = TReferenceType.factory()
            obj_.build(child_)
            self.set_ReferenceType(obj_)
        elif nodeName_ == 'RowType': 
            obj_ = TRowType.factory()
            obj_.build(child_)
            self.set_RowType(obj_)
# end class TFunctionParameter


class TCollectionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Nullable=None, DefaultValue=None, Precision=None, Unicode=None, MaxLength=None, Collation=None, ElementType=None, CollectionType=None, ReferenceType=None, RowType=None, TypeRef=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Collation = _cast(None, Collation)
        self.ElementType = _cast(None, ElementType)
        self.CollectionType = CollectionType
        self.ReferenceType = ReferenceType
        self.RowType = RowType
        self.TypeRef = TypeRef
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TCollectionType.subclass:
            return TCollectionType.subclass(*args_, **kwargs_)
        else:
            return TCollectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionType(self): return self.CollectionType
    def set_CollectionType(self, CollectionType): self.CollectionType = CollectionType
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def get_RowType(self): return self.RowType
    def set_RowType(self, RowType): self.RowType = RowType
    def get_TypeRef(self): return self.TypeRef
    def set_TypeRef(self, TypeRef): self.TypeRef = TypeRef
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_ElementType(self): return self.ElementType
    def set_ElementType(self, ElementType): self.ElementType = ElementType
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TCollectionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TCollectionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TCollectionType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            outfile.write(' ElementType=%s' % (quote_attrib(self.ElementType), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TCollectionType', fromsubclass_=False):
        if self.CollectionType:
            self.CollectionType.export(outfile, level, namespace_, name_='CollectionType')
        if self.ReferenceType:
            self.ReferenceType.export(outfile, level, namespace_, name_='ReferenceType')
        if self.RowType:
            self.RowType.export(outfile, level, namespace_, name_='RowType')
        if self.TypeRef:
            self.TypeRef.export(outfile, level, namespace_, name_='TypeRef')
    def hasContent_(self):
        if (
            self.CollectionType is not None or
            self.ReferenceType is not None or
            self.RowType is not None or
            self.TypeRef is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TCollectionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.ElementType is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            showIndent(outfile, level)
            outfile.write('ElementType = %s,\n' % (self.ElementType,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CollectionType is not None:
            showIndent(outfile, level)
            outfile.write('CollectionType=model_.TCollectionType(\n')
            self.CollectionType.exportLiteral(outfile, level, name_='CollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReferenceType is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceType=model_.TReferenceType(\n')
            self.ReferenceType.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RowType is not None:
            showIndent(outfile, level)
            outfile.write('RowType=model_.TRowType(\n')
            self.RowType.exportLiteral(outfile, level, name_='RowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TypeRef is not None:
            showIndent(outfile, level)
            outfile.write('TypeRef=model_.TTypeRef(\n')
            self.TypeRef.exportLiteral(outfile, level, name_='TypeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('ElementType')
        if value is not None and 'ElementType' not in already_processed:
            already_processed.append('ElementType')
            self.ElementType = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionType': 
            obj_ = TCollectionType.factory()
            obj_.build(child_)
            self.set_CollectionType(obj_)
        elif nodeName_ == 'ReferenceType': 
            obj_ = TReferenceType.factory()
            obj_.build(child_)
            self.set_ReferenceType(obj_)
        elif nodeName_ == 'RowType': 
            obj_ = TRowType.factory()
            obj_.build(child_)
            self.set_RowType(obj_)
        elif nodeName_ == 'TypeRef': 
            obj_ = TTypeRef.factory()
            obj_.build(child_)
            self.set_TypeRef(obj_)
# end class TCollectionType


class TTypeRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Nullable=None, DefaultValue=None, Precision=None, Unicode=None, MaxLength=None, Collation=None, Type=None, Documentation=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TTypeRef.subclass:
            return TTypeRef.subclass(*args_, **kwargs_)
        else:
            return TTypeRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TTypeRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TTypeRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TTypeRef'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TTypeRef', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TTypeRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TTypeRef


class TReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Documentation=None):
        self.Type = _cast(None, Type)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TReferenceType.subclass:
            return TReferenceType.subclass(*args_, **kwargs_)
        else:
            return TReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TReferenceType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TReferenceType', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TReferenceType


class TRowType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Property=None):
        self.Property = Property
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TRowType.subclass:
            return TRowType.subclass(*args_, **kwargs_)
        else:
            return TRowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TRowType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TRowType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TRowType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TRowType', fromsubclass_=False):
        if self.Property:
            self.Property.export(outfile, level, namespace_, name_='Property')
    def hasContent_(self):
        if (
            self.Property is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TRowType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Property is not None:
            showIndent(outfile, level)
            outfile.write('Property=model_.TProperty(\n')
            self.Property.exportLiteral(outfile, level, name_='Property')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property': 
            obj_ = TProperty.factory()
            obj_.build(child_)
            self.set_Property(obj_)
# end class TRowType


class TProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Name=None, Nullable=None, DefaultValue=None, Precision=None, Unicode=None, MaxLength=None, Collation=None, Type=None, CollectionType=None, ReferenceType=None, RowType=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.CollectionType = CollectionType
        self.ReferenceType = ReferenceType
        self.RowType = RowType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TProperty.subclass:
            return TProperty.subclass(*args_, **kwargs_)
        else:
            return TProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionType(self): return self.CollectionType
    def set_CollectionType(self, CollectionType): self.CollectionType = CollectionType
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def get_RowType(self): return self.RowType
    def set_RowType(self, RowType): self.RowType = RowType
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TProperty', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TProperty')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TProperty'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TProperty', fromsubclass_=False):
        if self.CollectionType:
            self.CollectionType.export(outfile, level, namespace_, name_='CollectionType')
        if self.ReferenceType:
            self.ReferenceType.export(outfile, level, namespace_, name_='ReferenceType')
        if self.RowType:
            self.RowType.export(outfile, level, namespace_, name_='RowType')
    def hasContent_(self):
        if (
            self.CollectionType is not None or
            self.ReferenceType is not None or
            self.RowType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CollectionType is not None:
            showIndent(outfile, level)
            outfile.write('CollectionType=model_.TCollectionType(\n')
            self.CollectionType.exportLiteral(outfile, level, name_='CollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReferenceType is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceType=model_.TReferenceType(\n')
            self.ReferenceType.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RowType is not None:
            showIndent(outfile, level)
            outfile.write('RowType=model_.TRowType(\n')
            self.RowType.exportLiteral(outfile, level, name_='RowType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionType': 
            obj_ = TCollectionType.factory()
            obj_.build(child_)
            self.set_CollectionType(obj_)
        elif nodeName_ == 'ReferenceType': 
            obj_ = TReferenceType.factory()
            obj_.build(child_)
            self.set_ReferenceType(obj_)
        elif nodeName_ == 'RowType': 
            obj_ = TRowType.factory()
            obj_.build(child_)
            self.set_RowType(obj_)
# end class TProperty


class TFunctionReturnType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Nullable=None, DefaultValue=None, Precision=None, Unicode=None, MaxLength=None, Collation=None, Type=None, CollectionType=None, ReferenceType=None, RowType=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.Precision = _cast(None, Precision)
        self.Unicode = _cast(None, Unicode)
        self.MaxLength = _cast(None, MaxLength)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.CollectionType = CollectionType
        self.ReferenceType = ReferenceType
        self.RowType = RowType
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TFunctionReturnType.subclass:
            return TFunctionReturnType.subclass(*args_, **kwargs_)
        else:
            return TFunctionReturnType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CollectionType(self): return self.CollectionType
    def set_CollectionType(self, CollectionType): self.CollectionType = CollectionType
    def get_ReferenceType(self): return self.ReferenceType
    def set_ReferenceType(self, ReferenceType): self.ReferenceType = ReferenceType
    def get_RowType(self): return self.RowType
    def set_RowType(self, RowType): self.RowType = RowType
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TFunctionReturnType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TFunctionReturnType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TFunctionReturnType'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TFunctionReturnType', fromsubclass_=False):
        if self.CollectionType:
            self.CollectionType.export(outfile, level, namespace_, name_='CollectionType')
        if self.ReferenceType:
            self.ReferenceType.export(outfile, level, namespace_, name_='ReferenceType')
        if self.RowType:
            self.RowType.export(outfile, level, namespace_, name_='RowType')
    def hasContent_(self):
        if (
            self.CollectionType is not None or
            self.ReferenceType is not None or
            self.RowType is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TFunctionReturnType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CollectionType is not None:
            showIndent(outfile, level)
            outfile.write('CollectionType=model_.TCollectionType(\n')
            self.CollectionType.exportLiteral(outfile, level, name_='CollectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReferenceType is not None:
            showIndent(outfile, level)
            outfile.write('ReferenceType=model_.TReferenceType(\n')
            self.ReferenceType.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RowType is not None:
            showIndent(outfile, level)
            outfile.write('RowType=model_.TRowType(\n')
            self.RowType.exportLiteral(outfile, level, name_='RowType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CollectionType': 
            obj_ = TCollectionType.factory()
            obj_.build(child_)
            self.set_CollectionType(obj_)
        elif nodeName_ == 'ReferenceType': 
            obj_ = TReferenceType.factory()
            obj_.build(child_)
            self.set_ReferenceType(obj_)
        elif nodeName_ == 'RowType': 
            obj_ = TRowType.factory()
            obj_.build(child_)
            self.set_RowType(obj_)
# end class TFunctionReturnType


class TEntityKeyElement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PropertyRef=None):
        if PropertyRef is None:
            self.PropertyRef = []
        else:
            self.PropertyRef = PropertyRef
    def factory(*args_, **kwargs_):
        if TEntityKeyElement.subclass:
            return TEntityKeyElement.subclass(*args_, **kwargs_)
        else:
            return TEntityKeyElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PropertyRef(self): return self.PropertyRef
    def set_PropertyRef(self, PropertyRef): self.PropertyRef = PropertyRef
    def add_PropertyRef(self, value): self.PropertyRef.append(value)
    def insert_PropertyRef(self, index, value): self.PropertyRef[index] = value
    def export(self, outfile, level, namespace_='edm:', name_='TEntityKeyElement', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TEntityKeyElement')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TEntityKeyElement'):
        pass
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TEntityKeyElement', fromsubclass_=False):
        for PropertyRef_ in self.PropertyRef:
            PropertyRef_.export(outfile, level, namespace_, name_='PropertyRef')
    def hasContent_(self):
        if (
            self.PropertyRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TEntityKeyElement'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PropertyRef=[\n')
        level += 1
        for PropertyRef_ in self.PropertyRef:
            showIndent(outfile, level)
            outfile.write('model_.TPropertyRef(\n')
            PropertyRef_.exportLiteral(outfile, level, name_='TPropertyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PropertyRef': 
            obj_ = TPropertyRef.factory()
            obj_.build(child_)
            self.PropertyRef.append(obj_)
# end class TEntityKeyElement


class TPropertyRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, valueOf_=None):
        self.Name = _cast(None, Name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TPropertyRef.subclass:
            return TPropertyRef.subclass(*args_, **kwargs_)
        else:
            return TPropertyRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='edm:', name_='TPropertyRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TPropertyRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TPropertyRef'):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TPropertyRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TPropertyRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TPropertyRef


class TAssociationEnd(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Role=None, Type=None, Multiplicity=None, Documentation=None, OnDelete=None):
        self.Role = _cast(None, Role)
        self.Type = _cast(None, Type)
        self.Multiplicity = _cast(None, Multiplicity)
        self.Documentation = Documentation
        self.OnDelete = OnDelete
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TAssociationEnd.subclass:
            return TAssociationEnd.subclass(*args_, **kwargs_)
        else:
            return TAssociationEnd(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_OnDelete(self): return self.OnDelete
    def set_OnDelete(self, OnDelete): self.OnDelete = OnDelete
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Multiplicity(self): return self.Multiplicity
    def set_Multiplicity(self, Multiplicity): self.Multiplicity = Multiplicity
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TAssociationEnd', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TAssociationEnd')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TAssociationEnd'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            outfile.write(' Role=%s' % (quote_attrib(self.Role), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Multiplicity is not None and 'Multiplicity' not in already_processed:
            already_processed.append('Multiplicity')
            outfile.write(' Multiplicity=%s' % (quote_attrib(self.Multiplicity), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TAssociationEnd', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        if self.OnDelete:
            self.OnDelete.export(outfile, level, namespace_, name_='OnDelete')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.OnDelete is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TAssociationEnd'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            showIndent(outfile, level)
            outfile.write('Role = %s,\n' % (self.Role,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.Multiplicity is not None and 'Multiplicity' not in already_processed:
            already_processed.append('Multiplicity')
            showIndent(outfile, level)
            outfile.write('Multiplicity = %s,\n' % (self.Multiplicity,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OnDelete is not None:
            showIndent(outfile, level)
            outfile.write('OnDelete=model_.TOnAction(\n')
            self.OnDelete.exportLiteral(outfile, level, name_='OnDelete')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Role')
        if value is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            self.Role = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = attrs.get('Multiplicity')
        if value is not None and 'Multiplicity' not in already_processed:
            already_processed.append('Multiplicity')
            self.Multiplicity = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'OnDelete': 
            obj_ = TOnAction.factory()
            obj_.build(child_)
            self.set_OnDelete(obj_)
# end class TAssociationEnd


class TOnAction(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Action=None, Documentation=None):
        self.Action = _cast(None, Action)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TOnAction.subclass:
            return TOnAction.subclass(*args_, **kwargs_)
        else:
            return TOnAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TOnAction', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TOnAction')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TOnAction'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Action is not None and 'Action' not in already_processed:
            already_processed.append('Action')
            outfile.write(' Action=%s' % (quote_attrib(self.Action), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TOnAction', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TOnAction'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Action is not None and 'Action' not in already_processed:
            already_processed.append('Action')
            showIndent(outfile, level)
            outfile.write('Action = %s,\n' % (self.Action,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Action')
        if value is not None and 'Action' not in already_processed:
            already_processed.append('Action')
            self.Action = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TOnAction


class TEntityProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, StoreGeneratedPattern=None, Scale=None, Name=None, Nullable=True, DefaultValue=None, MaxLength=None, Precision=None, FixedLength=None, GetterAccess=None, Unicode=None, SetterAccess=None, Collation=None, Type=None, ConcurrencyMode=None, Documentation=None):
        self.StoreGeneratedPattern = _cast(None, StoreGeneratedPattern)
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.MaxLength = _cast(None, MaxLength)
        self.Precision = _cast(None, Precision)
        self.FixedLength = _cast(None, FixedLength)
        self.GetterAccess = _cast(None, GetterAccess)
        self.Unicode = _cast(None, Unicode)
        self.SetterAccess = _cast(None, SetterAccess)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.ConcurrencyMode = _cast(None, ConcurrencyMode)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TEntityProperty.subclass:
            return TEntityProperty.subclass(*args_, **kwargs_)
        else:
            return TEntityProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_StoreGeneratedPattern(self): return self.StoreGeneratedPattern
    def set_StoreGeneratedPattern(self, StoreGeneratedPattern): self.StoreGeneratedPattern = StoreGeneratedPattern
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_GetterAccess(self): return self.GetterAccess
    def set_GetterAccess(self, GetterAccess): self.GetterAccess = GetterAccess
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_SetterAccess(self): return self.SetterAccess
    def set_SetterAccess(self, SetterAccess): self.SetterAccess = SetterAccess
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ConcurrencyMode(self): return self.ConcurrencyMode
    def set_ConcurrencyMode(self, ConcurrencyMode): self.ConcurrencyMode = ConcurrencyMode
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TEntityProperty', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TEntityProperty')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TEntityProperty'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.StoreGeneratedPattern is not None and 'StoreGeneratedPattern' not in already_processed:
            already_processed.append('StoreGeneratedPattern')
            outfile.write(' StoreGeneratedPattern=%s' % (self.gds_format_string(quote_attrib(self.StoreGeneratedPattern).encode(ExternalEncoding), input_name='StoreGeneratedPattern'), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            outfile.write(' GetterAccess=%s' % (self.gds_format_string(quote_attrib(self.GetterAccess).encode(ExternalEncoding), input_name='GetterAccess'), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            outfile.write(' SetterAccess=%s' % (self.gds_format_string(quote_attrib(self.SetterAccess).encode(ExternalEncoding), input_name='SetterAccess'), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ConcurrencyMode is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            outfile.write(' ConcurrencyMode=%s' % (quote_attrib(self.ConcurrencyMode), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TEntityProperty', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TEntityProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.StoreGeneratedPattern is not None and 'StoreGeneratedPattern' not in already_processed:
            already_processed.append('StoreGeneratedPattern')
            showIndent(outfile, level)
            outfile.write('StoreGeneratedPattern = "%s",\n' % (self.StoreGeneratedPattern,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            showIndent(outfile, level)
            outfile.write('GetterAccess = "%s",\n' % (self.GetterAccess,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            showIndent(outfile, level)
            outfile.write('SetterAccess = "%s",\n' % (self.SetterAccess,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.ConcurrencyMode is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            showIndent(outfile, level)
            outfile.write('ConcurrencyMode = %s,\n' % (self.ConcurrencyMode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('StoreGeneratedPattern')
        if value is not None and 'StoreGeneratedPattern' not in already_processed:
            already_processed.append('StoreGeneratedPattern')
            self.StoreGeneratedPattern = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('GetterAccess')
        if value is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            self.GetterAccess = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('SetterAccess')
        if value is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            self.SetterAccess = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = attrs.get('ConcurrencyMode')
        if value is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            self.ConcurrencyMode = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TEntityProperty


class TComplexTypeProperty(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FixedLength=None, Scale=None, Name=None, Nullable=True, DefaultValue=None, MaxLength=None, Precision=None, GetterAccess=None, Unicode=None, SetterAccess=None, Collation=None, Type=None, ConcurrencyMode=None, Documentation=None):
        self.FixedLength = _cast(None, FixedLength)
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Nullable = _cast(bool, Nullable)
        self.DefaultValue = _cast(None, DefaultValue)
        self.MaxLength = _cast(None, MaxLength)
        self.Precision = _cast(None, Precision)
        self.GetterAccess = _cast(None, GetterAccess)
        self.Unicode = _cast(None, Unicode)
        self.SetterAccess = _cast(None, SetterAccess)
        self.Collation = _cast(None, Collation)
        self.Type = _cast(None, Type)
        self.ConcurrencyMode = _cast(None, ConcurrencyMode)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TComplexTypeProperty.subclass:
            return TComplexTypeProperty.subclass(*args_, **kwargs_)
        else:
            return TComplexTypeProperty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_FixedLength(self): return self.FixedLength
    def set_FixedLength(self, FixedLength): self.FixedLength = FixedLength
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Nullable(self): return self.Nullable
    def set_Nullable(self, Nullable): self.Nullable = Nullable
    def get_DefaultValue(self): return self.DefaultValue
    def set_DefaultValue(self, DefaultValue): self.DefaultValue = DefaultValue
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_GetterAccess(self): return self.GetterAccess
    def set_GetterAccess(self, GetterAccess): self.GetterAccess = GetterAccess
    def get_Unicode(self): return self.Unicode
    def set_Unicode(self, Unicode): self.Unicode = Unicode
    def get_SetterAccess(self): return self.SetterAccess
    def set_SetterAccess(self, SetterAccess): self.SetterAccess = SetterAccess
    def get_Collation(self): return self.Collation
    def set_Collation(self, Collation): self.Collation = Collation
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_ConcurrencyMode(self): return self.ConcurrencyMode
    def set_ConcurrencyMode(self, ConcurrencyMode): self.ConcurrencyMode = ConcurrencyMode
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TComplexTypeProperty', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TComplexTypeProperty')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TComplexTypeProperty'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            outfile.write(' FixedLength=%s' % (quote_attrib(self.FixedLength), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            outfile.write(' Nullable="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.Nullable)), input_name='Nullable'))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            outfile.write(' DefaultValue=%s' % (self.gds_format_string(quote_attrib(self.DefaultValue).encode(ExternalEncoding), input_name='DefaultValue'), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            outfile.write(' GetterAccess=%s' % (self.gds_format_string(quote_attrib(self.GetterAccess).encode(ExternalEncoding), input_name='GetterAccess'), ))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            outfile.write(' Unicode=%s' % (quote_attrib(self.Unicode), ))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            outfile.write(' SetterAccess=%s' % (self.gds_format_string(quote_attrib(self.SetterAccess).encode(ExternalEncoding), input_name='SetterAccess'), ))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            outfile.write(' Collation=%s' % (quote_attrib(self.Collation), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.ConcurrencyMode is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            outfile.write(' ConcurrencyMode=%s' % (quote_attrib(self.ConcurrencyMode), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TComplexTypeProperty', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TComplexTypeProperty'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.FixedLength is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            showIndent(outfile, level)
            outfile.write('FixedLength = %s,\n' % (self.FixedLength,))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Nullable is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            showIndent(outfile, level)
            outfile.write('Nullable = %s,\n' % (self.Nullable,))
        if self.DefaultValue is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            showIndent(outfile, level)
            outfile.write('DefaultValue = "%s",\n' % (self.DefaultValue,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            showIndent(outfile, level)
            outfile.write('GetterAccess = "%s",\n' % (self.GetterAccess,))
        if self.Unicode is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            showIndent(outfile, level)
            outfile.write('Unicode = %s,\n' % (self.Unicode,))
        if self.SetterAccess is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            showIndent(outfile, level)
            outfile.write('SetterAccess = "%s",\n' % (self.SetterAccess,))
        if self.Collation is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            showIndent(outfile, level)
            outfile.write('Collation = %s,\n' % (self.Collation,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.ConcurrencyMode is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            showIndent(outfile, level)
            outfile.write('ConcurrencyMode = %s,\n' % (self.ConcurrencyMode,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('FixedLength')
        if value is not None and 'FixedLength' not in already_processed:
            already_processed.append('FixedLength')
            self.FixedLength = value
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Nullable')
        if value is not None and 'Nullable' not in already_processed:
            already_processed.append('Nullable')
            if value in ('true', '1'):
                self.Nullable = True
            elif value in ('false', '0'):
                self.Nullable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('DefaultValue')
        if value is not None and 'DefaultValue' not in already_processed:
            already_processed.append('DefaultValue')
            self.DefaultValue = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('GetterAccess')
        if value is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            self.GetterAccess = value
        value = attrs.get('Unicode')
        if value is not None and 'Unicode' not in already_processed:
            already_processed.append('Unicode')
            self.Unicode = value
        value = attrs.get('SetterAccess')
        if value is not None and 'SetterAccess' not in already_processed:
            already_processed.append('SetterAccess')
            self.SetterAccess = value
        value = attrs.get('Collation')
        if value is not None and 'Collation' not in already_processed:
            already_processed.append('Collation')
            self.Collation = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        value = attrs.get('ConcurrencyMode')
        if value is not None and 'ConcurrencyMode' not in already_processed:
            already_processed.append('ConcurrencyMode')
            self.ConcurrencyMode = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TComplexTypeProperty


class TFunctionImportParameter(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Scale=None, Name=None, Precision=None, Mode=None, MaxLength=None, Type=None, Documentation=None):
        self.Scale = _cast(None, Scale)
        self.Name = _cast(None, Name)
        self.Precision = _cast(None, Precision)
        self.Mode = _cast(None, Mode)
        self.MaxLength = _cast(None, MaxLength)
        self.Type = _cast(None, Type)
        self.Documentation = Documentation
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if TFunctionImportParameter.subclass:
            return TFunctionImportParameter.subclass(*args_, **kwargs_)
        else:
            return TFunctionImportParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Scale(self): return self.Scale
    def set_Scale(self, Scale): self.Scale = Scale
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Precision(self): return self.Precision
    def set_Precision(self, Precision): self.Precision = Precision
    def get_Mode(self): return self.Mode
    def set_Mode(self, Mode): self.Mode = Mode
    def get_MaxLength(self): return self.MaxLength
    def set_MaxLength(self, MaxLength): self.MaxLength = MaxLength
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='TFunctionImportParameter', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='TFunctionImportParameter')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='TFunctionImportParameter'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            outfile.write(' Scale=%s' % (quote_attrib(self.Scale), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            outfile.write(' Precision=%s' % (quote_attrib(self.Precision), ))
        if self.Mode is not None and 'Mode' not in already_processed:
            already_processed.append('Mode')
            outfile.write(' Mode=%s' % (quote_attrib(self.Mode), ))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            outfile.write(' MaxLength=%s' % (quote_attrib(self.MaxLength), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='TFunctionImportParameter', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
    def hasContent_(self):
        if (
            self.Documentation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TFunctionImportParameter'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Scale is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            showIndent(outfile, level)
            outfile.write('Scale = %s,\n' % (self.Scale,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Precision is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            showIndent(outfile, level)
            outfile.write('Precision = %s,\n' % (self.Precision,))
        if self.Mode is not None and 'Mode' not in already_processed:
            already_processed.append('Mode')
            showIndent(outfile, level)
            outfile.write('Mode = %s,\n' % (self.Mode,))
        if self.MaxLength is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            showIndent(outfile, level)
            outfile.write('MaxLength = %s,\n' % (self.MaxLength,))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Scale')
        if value is not None and 'Scale' not in already_processed:
            already_processed.append('Scale')
            self.Scale = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Precision')
        if value is not None and 'Precision' not in already_processed:
            already_processed.append('Precision')
            self.Precision = value
        value = attrs.get('Mode')
        if value is not None and 'Mode' not in already_processed:
            already_processed.append('Mode')
            self.Mode = value
        value = attrs.get('MaxLength')
        if value is not None and 'MaxLength' not in already_processed:
            already_processed.append('MaxLength')
            self.MaxLength = value
        value = attrs.get('Type')
        if value is not None and 'Type' not in already_processed:
            already_processed.append('Type')
            self.Type = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
# end class TFunctionImportParameter


class EntityContainer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, TypeAccess=None, LazyLoadingEnabled=None, Extends=None, Name=None, Documentation=None, FunctionImport=None, EntitySet=None, AssociationSet=None):
        self.TypeAccess = _cast(None, TypeAccess)
        self.LazyLoadingEnabled = _cast(None, LazyLoadingEnabled)
        self.Extends = _cast(None, Extends)
        self.Name = _cast(None, Name)
        self.Documentation = Documentation
        if FunctionImport is None:
            self.FunctionImport = []
        else:
            self.FunctionImport = FunctionImport
        if EntitySet is None:
            self.EntitySet = []
        else:
            self.EntitySet = EntitySet
        if AssociationSet is None:
            self.AssociationSet = []
        else:
            self.AssociationSet = AssociationSet
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EntityContainer.subclass:
            return EntityContainer.subclass(*args_, **kwargs_)
        else:
            return EntityContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_FunctionImport(self): return self.FunctionImport
    def set_FunctionImport(self, FunctionImport): self.FunctionImport = FunctionImport
    def add_FunctionImport(self, value): self.FunctionImport.append(value)
    def insert_FunctionImport(self, index, value): self.FunctionImport[index] = value
    def get_EntitySet(self): return self.EntitySet
    def set_EntitySet(self, EntitySet): self.EntitySet = EntitySet
    def add_EntitySet(self, value): self.EntitySet.append(value)
    def insert_EntitySet(self, index, value): self.EntitySet[index] = value
    def get_AssociationSet(self): return self.AssociationSet
    def set_AssociationSet(self, AssociationSet): self.AssociationSet = AssociationSet
    def add_AssociationSet(self, value): self.AssociationSet.append(value)
    def insert_AssociationSet(self, index, value): self.AssociationSet[index] = value
    def get_TypeAccess(self): return self.TypeAccess
    def set_TypeAccess(self, TypeAccess): self.TypeAccess = TypeAccess
    def get_LazyLoadingEnabled(self): return self.LazyLoadingEnabled
    def set_LazyLoadingEnabled(self, LazyLoadingEnabled): self.LazyLoadingEnabled = LazyLoadingEnabled
    def get_Extends(self): return self.Extends
    def set_Extends(self, Extends): self.Extends = Extends
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='EntityContainer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='EntityContainer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='EntityContainer'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            outfile.write(' TypeAccess=%s' % (self.gds_format_string(quote_attrib(self.TypeAccess).encode(ExternalEncoding), input_name='TypeAccess'), ))
        if self.LazyLoadingEnabled is not None and 'LazyLoadingEnabled' not in already_processed:
            already_processed.append('LazyLoadingEnabled')
            outfile.write(' LazyLoadingEnabled=%s' % (self.gds_format_string(quote_attrib(self.LazyLoadingEnabled).encode(ExternalEncoding), input_name='LazyLoadingEnabled'), ))
        if self.Extends is not None and 'Extends' not in already_processed:
            already_processed.append('Extends')
            outfile.write(' Extends=%s' % (quote_attrib(self.Extends), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='EntityContainer', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for FunctionImport_ in self.FunctionImport:
            FunctionImport_.export(outfile, level, namespace_, name_='FunctionImport')
        for EntitySet_ in self.EntitySet:
            EntitySet_.export(outfile, level, namespace_, name_='EntitySet')
        for AssociationSet_ in self.AssociationSet:
            AssociationSet_.export(outfile, level, namespace_, name_='AssociationSet')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.FunctionImport or
            self.EntitySet or
            self.AssociationSet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityContainer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.TypeAccess is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            showIndent(outfile, level)
            outfile.write('TypeAccess = "%s",\n' % (self.TypeAccess,))
        if self.LazyLoadingEnabled is not None and 'LazyLoadingEnabled' not in already_processed:
            already_processed.append('LazyLoadingEnabled')
            showIndent(outfile, level)
            outfile.write('LazyLoadingEnabled = "%s",\n' % (self.LazyLoadingEnabled,))
        if self.Extends is not None and 'Extends' not in already_processed:
            already_processed.append('Extends')
            showIndent(outfile, level)
            outfile.write('Extends = %s,\n' % (self.Extends,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('FunctionImport=[\n')
        level += 1
        for FunctionImport_ in self.FunctionImport:
            showIndent(outfile, level)
            outfile.write('model_.FunctionImport(\n')
            FunctionImport_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EntitySet=[\n')
        level += 1
        for EntitySet_ in self.EntitySet:
            showIndent(outfile, level)
            outfile.write('model_.EntitySet(\n')
            EntitySet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AssociationSet=[\n')
        level += 1
        for AssociationSet_ in self.AssociationSet:
            showIndent(outfile, level)
            outfile.write('model_.AssociationSet(\n')
            AssociationSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('TypeAccess')
        if value is not None and 'TypeAccess' not in already_processed:
            already_processed.append('TypeAccess')
            self.TypeAccess = value
        value = attrs.get('LazyLoadingEnabled')
        if value is not None and 'LazyLoadingEnabled' not in already_processed:
            already_processed.append('LazyLoadingEnabled')
            self.LazyLoadingEnabled = value
        value = attrs.get('Extends')
        if value is not None and 'Extends' not in already_processed:
            already_processed.append('Extends')
            self.Extends = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'FunctionImport': 
            obj_ = FunctionImport.factory()
            obj_.build(child_)
            self.FunctionImport.append(obj_)
        elif nodeName_ == 'EntitySet': 
            obj_ = EntitySet.factory()
            obj_.build(child_)
            self.EntitySet.append(obj_)
        elif nodeName_ == 'AssociationSet': 
            obj_ = AssociationSet.factory()
            obj_.build(child_)
            self.AssociationSet.append(obj_)
# end class EntityContainer


class FunctionImport(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ReturnType=None, MethodAccess=None, EntitySet=None, Name=None, Documentation=None, Parameter=None):
        self.ReturnType = _cast(None, ReturnType)
        self.MethodAccess = _cast(None, MethodAccess)
        self.EntitySet = _cast(None, EntitySet)
        self.Name = _cast(None, Name)
        self.Documentation = Documentation
        if Parameter is None:
            self.Parameter = []
        else:
            self.Parameter = Parameter
    def factory(*args_, **kwargs_):
        if FunctionImport.subclass:
            return FunctionImport.subclass(*args_, **kwargs_)
        else:
            return FunctionImport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_Parameter(self): return self.Parameter
    def set_Parameter(self, Parameter): self.Parameter = Parameter
    def add_Parameter(self, value): self.Parameter.append(value)
    def insert_Parameter(self, index, value): self.Parameter[index] = value
    def get_ReturnType(self): return self.ReturnType
    def set_ReturnType(self, ReturnType): self.ReturnType = ReturnType
    def get_MethodAccess(self): return self.MethodAccess
    def set_MethodAccess(self, MethodAccess): self.MethodAccess = MethodAccess
    def get_EntitySet(self): return self.EntitySet
    def set_EntitySet(self, EntitySet): self.EntitySet = EntitySet
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def export(self, outfile, level, namespace_='edm:', name_='FunctionImport', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='FunctionImport')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='FunctionImport'):
        if self.ReturnType is not None and 'ReturnType' not in already_processed:
            already_processed.append('ReturnType')
            outfile.write(' ReturnType=%s' % (quote_attrib(self.ReturnType), ))
        if self.MethodAccess is not None and 'MethodAccess' not in already_processed:
            already_processed.append('MethodAccess')
            outfile.write(' MethodAccess=%s' % (self.gds_format_string(quote_attrib(self.MethodAccess).encode(ExternalEncoding), input_name='MethodAccess'), ))
        if self.EntitySet is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            outfile.write(' EntitySet=%s' % (quote_attrib(self.EntitySet), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='FunctionImport', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for Parameter_ in self.Parameter:
            Parameter_.export(outfile, level, namespace_, name_='Parameter')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.Parameter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FunctionImport'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ReturnType is not None and 'ReturnType' not in already_processed:
            already_processed.append('ReturnType')
            showIndent(outfile, level)
            outfile.write('ReturnType = %s,\n' % (self.ReturnType,))
        if self.MethodAccess is not None and 'MethodAccess' not in already_processed:
            already_processed.append('MethodAccess')
            showIndent(outfile, level)
            outfile.write('MethodAccess = "%s",\n' % (self.MethodAccess,))
        if self.EntitySet is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            showIndent(outfile, level)
            outfile.write('EntitySet = %s,\n' % (self.EntitySet,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Parameter=[\n')
        level += 1
        for Parameter_ in self.Parameter:
            showIndent(outfile, level)
            outfile.write('model_.TFunctionImportParameter(\n')
            Parameter_.exportLiteral(outfile, level, name_='TFunctionImportParameter')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('ReturnType')
        if value is not None and 'ReturnType' not in already_processed:
            already_processed.append('ReturnType')
            self.ReturnType = value
        value = attrs.get('MethodAccess')
        if value is not None and 'MethodAccess' not in already_processed:
            already_processed.append('MethodAccess')
            self.MethodAccess = value
        value = attrs.get('EntitySet')
        if value is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            self.EntitySet = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'Parameter': 
            obj_ = TFunctionImportParameter.factory()
            obj_.build(child_)
            self.Parameter.append(obj_)
# end class FunctionImport


class EntitySet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GetterAccess=None, EntityType=None, Name=None, GEmptyElementExtensibility=None):
        self.GetterAccess = _cast(None, GetterAccess)
        self.EntityType = _cast(None, EntityType)
        self.Name = _cast(None, Name)
        self.GEmptyElementExtensibility = GEmptyElementExtensibility
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EntitySet.subclass:
            return EntitySet.subclass(*args_, **kwargs_)
        else:
            return EntitySet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GEmptyElementExtensibility(self): return self.GEmptyElementExtensibility
    def set_GEmptyElementExtensibility(self, GEmptyElementExtensibility): self.GEmptyElementExtensibility = GEmptyElementExtensibility
    def get_GetterAccess(self): return self.GetterAccess
    def set_GetterAccess(self, GetterAccess): self.GetterAccess = GetterAccess
    def get_EntityType(self): return self.EntityType
    def set_EntityType(self, EntityType): self.EntityType = EntityType
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='EntitySet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='EntitySet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='EntitySet'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            outfile.write(' GetterAccess=%s' % (self.gds_format_string(quote_attrib(self.GetterAccess).encode(ExternalEncoding), input_name='GetterAccess'), ))
        if self.EntityType is not None and 'EntityType' not in already_processed:
            already_processed.append('EntityType')
            outfile.write(' EntityType=%s' % (quote_attrib(self.EntityType), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='EntitySet', fromsubclass_=False):
        if self.GEmptyElementExtensibility is not None:
            showIndent(outfile, level)
            outfile.write('<%sGEmptyElementExtensibility>%s</%sGEmptyElementExtensibility>\n' % (namespace_, self.gds_format_string(quote_xml(self.GEmptyElementExtensibility).encode(ExternalEncoding), input_name='GEmptyElementExtensibility'), namespace_))
    def hasContent_(self):
        if (
            self.GEmptyElementExtensibility is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntitySet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.GetterAccess is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            showIndent(outfile, level)
            outfile.write('GetterAccess = "%s",\n' % (self.GetterAccess,))
        if self.EntityType is not None and 'EntityType' not in already_processed:
            already_processed.append('EntityType')
            showIndent(outfile, level)
            outfile.write('EntityType = %s,\n' % (self.EntityType,))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GEmptyElementExtensibility is not None:
            showIndent(outfile, level)
            outfile.write('GEmptyElementExtensibility=%s,\n' % quote_python(self.GEmptyElementExtensibility).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('GetterAccess')
        if value is not None and 'GetterAccess' not in already_processed:
            already_processed.append('GetterAccess')
            self.GetterAccess = value
        value = attrs.get('EntityType')
        if value is not None and 'EntityType' not in already_processed:
            already_processed.append('EntityType')
            self.EntityType = value
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GEmptyElementExtensibility':
            GEmptyElementExtensibility_ = child_.text
            GEmptyElementExtensibility_ = self.gds_validate_string(GEmptyElementExtensibility_, node, 'GEmptyElementExtensibility')
            self.GEmptyElementExtensibility = GEmptyElementExtensibility_
# end class EntitySet


class AssociationSet(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Name=None, Association=None, Documentation=None, End=None):
        self.Name = _cast(None, Name)
        self.Association = _cast(None, Association)
        self.Documentation = Documentation
        if End is None:
            self.End = []
        else:
            self.End = End
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AssociationSet.subclass:
            return AssociationSet.subclass(*args_, **kwargs_)
        else:
            return AssociationSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Documentation(self): return self.Documentation
    def set_Documentation(self, Documentation): self.Documentation = Documentation
    def get_End(self): return self.End
    def set_End(self, End): self.End = End
    def add_End(self, value): self.End.append(value)
    def insert_End(self, index, value): self.End[index] = value
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Association(self): return self.Association
    def set_Association(self, Association): self.Association = Association
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='edm:', name_='AssociationSet', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='AssociationSet')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='AssociationSet'):
        for name, value in self.anyAttributes_.items():
            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            outfile.write(' Name=%s' % (quote_attrib(self.Name), ))
        if self.Association is not None and 'Association' not in already_processed:
            already_processed.append('Association')
            outfile.write(' Association=%s' % (quote_attrib(self.Association), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='AssociationSet', fromsubclass_=False):
        if self.Documentation:
            self.Documentation.export(outfile, level, namespace_, name_='Documentation')
        for End_ in self.End:
            End_.export(outfile, level, namespace_, name_='End')
    def hasContent_(self):
        if (
            self.Documentation is not None or
            self.End
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssociationSet'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.Name is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            showIndent(outfile, level)
            outfile.write('Name = %s,\n' % (self.Name,))
        if self.Association is not None and 'Association' not in already_processed:
            already_processed.append('Association')
            showIndent(outfile, level)
            outfile.write('Association = %s,\n' % (self.Association,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Documentation is not None:
            showIndent(outfile, level)
            outfile.write('Documentation=model_.TDocumentation(\n')
            self.Documentation.exportLiteral(outfile, level, name_='Documentation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('End=[\n')
        level += 1
        for End_ in self.End:
            showIndent(outfile, level)
            outfile.write('model_.End(\n')
            End_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('Name')
        if value is not None and 'Name' not in already_processed:
            already_processed.append('Name')
            self.Name = value
        value = attrs.get('Association')
        if value is not None and 'Association' not in already_processed:
            already_processed.append('Association')
            self.Association = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Documentation': 
            obj_ = TDocumentation.factory()
            obj_.build(child_)
            self.set_Documentation(obj_)
        elif nodeName_ == 'End': 
            obj_ = End.factory()
            obj_.build(child_)
            self.End.append(obj_)
# end class AssociationSet


class End(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EntitySet=None, Role=None, GEmptyElementExtensibility=None):
        self.EntitySet = _cast(None, EntitySet)
        self.Role = _cast(None, Role)
        self.GEmptyElementExtensibility = GEmptyElementExtensibility
    def factory(*args_, **kwargs_):
        if End.subclass:
            return End.subclass(*args_, **kwargs_)
        else:
            return End(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GEmptyElementExtensibility(self): return self.GEmptyElementExtensibility
    def set_GEmptyElementExtensibility(self, GEmptyElementExtensibility): self.GEmptyElementExtensibility = GEmptyElementExtensibility
    def get_EntitySet(self): return self.EntitySet
    def set_EntitySet(self, EntitySet): self.EntitySet = EntitySet
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def export(self, outfile, level, namespace_='edm:', name_='End', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, [], namespace_, name_='End')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='edm:', name_='End'):
        if self.EntitySet is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            outfile.write(' EntitySet=%s' % (quote_attrib(self.EntitySet), ))
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            outfile.write(' Role=%s' % (quote_attrib(self.Role), ))
    def exportChildren(self, outfile, level, namespace_='edm:', name_='End', fromsubclass_=False):
        if self.GEmptyElementExtensibility is not None:
            showIndent(outfile, level)
            outfile.write('<%sGEmptyElementExtensibility>%s</%sGEmptyElementExtensibility>\n' % (namespace_, self.gds_format_string(quote_xml(self.GEmptyElementExtensibility).encode(ExternalEncoding), input_name='GEmptyElementExtensibility'), namespace_))
    def hasContent_(self):
        if (
            self.GEmptyElementExtensibility is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='End'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.EntitySet is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            showIndent(outfile, level)
            outfile.write('EntitySet = %s,\n' % (self.EntitySet,))
        if self.Role is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            showIndent(outfile, level)
            outfile.write('Role = %s,\n' % (self.Role,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GEmptyElementExtensibility is not None:
            showIndent(outfile, level)
            outfile.write('GEmptyElementExtensibility=%s,\n' % quote_python(self.GEmptyElementExtensibility).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = attrs.get('EntitySet')
        if value is not None and 'EntitySet' not in already_processed:
            already_processed.append('EntitySet')
            self.EntitySet = value
        value = attrs.get('Role')
        if value is not None and 'Role' not in already_processed:
            already_processed.append('Role')
            self.Role = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GEmptyElementExtensibility':
            GEmptyElementExtensibility_ = child_.text
            GEmptyElementExtensibility_ = self.gds_validate_string(GEmptyElementExtensibility_, node, 'GEmptyElementExtensibility')
            self.GEmptyElementExtensibility = GEmptyElementExtensibility_
# end class End


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Schema'
        rootClass = TSchema
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Schema'
        rootClass = TSchema
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="Schema",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Schema'
        rootClass = TSchema
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from edmx import *\n\n')
    sys.stdout.write('import edmx as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AssociationSet",
    "End",
    "EntityContainer",
    "EntitySet",
    "FunctionImport",
    "TAssociation",
    "TAssociationEnd",
    "TCollectionType",
    "TComplexType",
    "TComplexTypeProperty",
    "TConstraint",
    "TDocumentation",
    "TEntityKeyElement",
    "TEntityProperty",
    "TEntityType",
    "TFunction",
    "TFunctionImportParameter",
    "TFunctionParameter",
    "TFunctionReturnType",
    "TNavigationProperty",
    "TOnAction",
    "TProperty",
    "TPropertyRef",
    "TReferenceType",
    "TReferentialConstraintRoleElement",
    "TRowType",
    "TSchema",
    "TText",
    "TTypeRef",
    "TUsing",
    "TXmlOrText"
    ]
